package tk.germanbot.data

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIndexHashKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIndexRangeKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperFieldModel.DynamoDBAttributeType.S
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBQueryExpression
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBRangeKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTyped
import com.amazonaws.services.dynamodbv2.datamodeling.PaginatedQueryList
import com.amazonaws.services.dynamodbv2.model.AttributeValue
import com.amazonaws.services.dynamodbv2.model.ComparisonOperator
import com.amazonaws.services.dynamodbv2.model.Condition
import com.google.common.collect.Sets
import org.socialsignin.spring.data.dynamodb.repository.EnableScan
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.data.repository.CrudRepository
import org.springframework.stereotype.Component
import tk.germanbot.service.EntityValidationException
import java.util.Date
import java.util.UUID


const val QUIZ_TABLE_NANE = "german_bot_quiz"
const val QUIZ_TOPIC_TABLE_NANE = "german_bot_quiz_topic"

@DynamoDBTable(tableName = QUIZ_TABLE_NANE)
data class Quiz(
        @DynamoDBHashKey
        @DynamoDBAutoGeneratedKey
        var id: String? = null,

        @DynamoDBAttribute
        @DynamoDBTyped(S)
        var date: Date = Date(),

        @DynamoDBAttribute
        var createdBy: String?,

        @DynamoDBAttribute
        var question: String?,

        @DynamoDBAttribute
        var answers: Set<String>?,

        @DynamoDBAttribute
        var example: String? = null,

        @DynamoDBAttribute
        var topics: Set<String> = setOf(QuizTopic.UNDEFINED),

        @DynamoDBAttribute
        var isPublished: Boolean = false

) {
    fun validate() {
        if (createdBy == null) throw EntityValidationException(Quiz::class, "CreatedBy is null in $id")
        if (answers == null || answers!!.isEmpty()) throw EntityValidationException(Quiz::class, "No answers for quiz $id")
        if (topics == null || topics!!.isEmpty()) throw EntityValidationException(Quiz::class, "No topics for quiz $id")
    }
}

@DynamoDBTable(tableName = QUIZ_TOPIC_TABLE_NANE)
data class QuizTopic(
        @DynamoDBHashKey
        @DynamoDBIndexRangeKey(globalSecondaryIndexName = "german_bot_idx_quiz_topic")
        var topic: String? = null,

        @DynamoDBRangeKey
        @DynamoDBIndexHashKey(globalSecondaryIndexName = "german_bot_idx_quiz_topic")
        var quizId: String? = null
) {
    companion object {

        val UNDEFINED = "**undef**"
        val PUBLISHED = "**pub**"

        fun getAllCombinations(topics: Set<String>): List<String> {
            return Sets.powerSet(topics)
                    .flatMap { set -> setOf(getTopicKey(set)) }
                    .filter(String::isNotBlank)
        }

        fun getTopicKey(set: Set<String>): String = set.sorted().joinToString("#")
    }

}

@EnableScan
interface QuizRepository : CrudRepository<Quiz, String> {
    fun save(quiz: Quiz): Quiz

    override fun findAll(): List<Quiz>

    fun findOneById(id: String): Quiz?

    fun findByTopicsContaining(topics: String): List<Quiz>

    fun findTop50ByIdGreaterThan(randomKey: String): List<Quiz>

    fun findTop50ByIdLessThan(randomKey: String): List<Quiz>
}

@Component
class QuizTopicRepository(
        @Autowired private val mapper: DynamoDBMapper
) {

    fun saveTopics(quiz: Quiz) {
        val quizTopics = generateTopics(quiz)

        val existingTopics = findTopics(quiz)
        val toDelete = existingTopics - quizTopics
        val toAdd = quizTopics - existingTopics

        if (toDelete.isNotEmpty()) {
            mapper.batchDelete(toDelete)
        }
        if (toAdd.isNotEmpty()) {
            mapper.batchSave(toAdd)
        }
    }

    fun findQuizIdsByTopics(topics: Set<String>): PaginatedQueryList<QuizTopic> {
        val quizByTopicExpression = DynamoDBQueryExpression<QuizTopic>()
                .withHashKeyValues(QuizTopic(topic = QuizTopic.getTopicKey(topics)))
                .withProjectionExpression("quizId")
        return mapper.query(QuizTopic::class.java, quizByTopicExpression)
    }

    fun findNRandomQuizIdsByTopics(topics: Set<String>, count: Int): List<QuizTopic> {
        val random = UUID.randomUUID().toString()
        val result = getRandomRange(topics, ComparisonOperator.LE, random, count)
        return if (result.size < count) {
            result + getRandomRange(topics, ComparisonOperator.GE, random, count - result.size)
        } else {
            result
        }
    }

    private fun getRandomRange(topics: Set<String>, operator: ComparisonOperator, random: String, count: Int): PaginatedQueryList<QuizTopic> {
        val quizByTopicExpression = DynamoDBQueryExpression<QuizTopic>()
                .withHashKeyValues(QuizTopic(topic = QuizTopic.getTopicKey(topics)))
                .withRangeKeyCondition("quizId",
                        Condition().withComparisonOperator(operator)
                                .withAttributeValueList(AttributeValue().withS(random)))
                .withProjectionExpression("quizId")
                .withLimit(count)
        return mapper.query(QuizTopic::class.java, quizByTopicExpression)
    }

    internal fun findTopics(quiz: Quiz): List<QuizTopic> {
        val quizTopicExpression = DynamoDBQueryExpression<QuizTopic>()
                .withIndexName("german_bot_idx_quiz_topic")
                .withKeyConditionExpression("quizId = :quizId")
                .withConsistentRead(false)
                .withExpressionAttributeValues(mapOf(":quizId" to AttributeValue().withS(quiz.id)))
        return mapper.query(QuizTopic::class.java, quizTopicExpression)
    }

    private fun generateTopics(quiz: Quiz): List<QuizTopic> {
        return if (quiz.isPublished)
            QuizTopic.getAllCombinations(quiz.topics!! + QuizTopic.PUBLISHED)
                    .filter { it.contains(QuizTopic.PUBLISHED) }
                    .map { topic -> QuizTopic(quizId = quiz.id, topic = topic) }
        else
            QuizTopic.getAllCombinations(quiz.topics + quiz.createdBy!!)
                    .filter { it.contains(quiz.createdBy!!) }
                    .map { topic -> QuizTopic(quizId = quiz.id, topic = topic) }

    }


}