package tk.germanbot.data

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIndexHashKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIndexRangeKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperFieldModel.DynamoDBAttributeType.S
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBQueryExpression
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBRangeKey
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBScanExpression
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTyped
import com.amazonaws.services.dynamodbv2.datamodeling.PaginatedQueryList
import com.amazonaws.services.dynamodbv2.model.AttributeValue
import com.google.common.collect.Sets
import org.socialsignin.spring.data.dynamodb.repository.EnableScan
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.data.repository.CrudRepository
import org.springframework.stereotype.Component
import tk.germanbot.service.EntityValidationException
import java.util.Date


const val QUIZ_TABLE_NANE = "german_bot_quiz"
const val QUIZ_TOPIC_TABLE_NANE = "german_bot_quiz_topic"

@DynamoDBTable(tableName = QUIZ_TABLE_NANE)
data class Quiz(
        @DynamoDBHashKey
        @DynamoDBAutoGeneratedKey
        var id: String? = null,

        @DynamoDBAttribute
        @DynamoDBTyped(S)
        var date: Date? = Date(),

        @DynamoDBAttribute
        var createdBy: String?,

        @DynamoDBAttribute
        var question: String?,

        @DynamoDBAttribute
        var answers: Set<String>?,

        @DynamoDBAttribute
        var topics: Set<String>?
) {
    fun validate() {
        if (answers == null || answers!!.isEmpty()) throw EntityValidationException(Quiz::class, "No answers for quiz $id")
        if (topics == null || topics!!.isEmpty()) throw EntityValidationException(Quiz::class, "No topics for quiz $id")
    }
}

@DynamoDBTable(tableName = QUIZ_TOPIC_TABLE_NANE)
data class QuizTopic(
        @DynamoDBHashKey
        @DynamoDBIndexRangeKey(globalSecondaryIndexName = "german_bot_idx_quiz_topic")
        var topic: String? = null,

        @DynamoDBRangeKey
        @DynamoDBIndexHashKey(globalSecondaryIndexName = "german_bot_idx_quiz_topic")
        var quizId: String? = null
)

@EnableScan
interface QuizRepository : CrudRepository<Quiz, String> {
    fun save(quiz: Quiz): Quiz

    override fun findAll(): List<Quiz>

    fun findOneById(id: String): Quiz?

    fun findByTopicsContaining(topics: String): List<Quiz>

    fun findTop5ByIdGreaterThan(randomKey: String): List<Quiz>

    fun findTop5ByIdLessThan(randomKey: String): List<Quiz>
}

@Component
class QuizTopicRepository(
        @Autowired private val mapper: DynamoDBMapper
) {

    fun saveTopics(quiz: Quiz) {
        val quizTopics = generateTopics(quiz)

        val existingTopics = findTopics(quiz)
        val toDelete = existingTopics - quizTopics
        val toAdd = quizTopics - existingTopics

        if (toDelete.isNotEmpty()) {
            mapper.batchDelete(toDelete)
        }
        if (toAdd.isNotEmpty()) {
            mapper.batchSave(toAdd)
        }
    }

    fun findQuizIdsByTopics(topics: Set<String>): PaginatedQueryList<QuizTopic> {
        val quizByTopicExpression = DynamoDBQueryExpression<QuizTopic>()
                .withHashKeyValues(QuizTopic(topic = getTopicKey(topics)))
                .withProjectionExpression("quizId")
        return mapper.query(QuizTopic::class.java, quizByTopicExpression)
    }

    private fun findAll(): List<QuizTopic> {
        return mapper.scan(QuizTopic::class.java, DynamoDBScanExpression())
    }

    internal fun findTopics(quiz: Quiz): List<QuizTopic> {
        val quizTopicExpression = DynamoDBQueryExpression<QuizTopic>()
                .withIndexName("german_bot_idx_quiz_topic")
                .withKeyConditionExpression("quizId = :quizId")
                .withConsistentRead(false)
                .withExpressionAttributeValues(mapOf(":quizId" to AttributeValue().withS(quiz.id)))
        return mapper.query(QuizTopic::class.java, quizTopicExpression)
    }

    private fun generateTopics(quiz: Quiz): List<QuizTopic> {
        return getAllCombinations(quiz.topics!!)
                .map { topic -> QuizTopic(quizId = quiz.id, topic = topic) }
    }

    private fun getAllCombinations(topics: Set<String>): List<String> {
        return Sets.powerSet(topics)
                .flatMap { set -> setOf(getTopicKey(set)) }
                .filter(String::isNotBlank)
    }

    private fun getTopicKey(set: Set<String>) = set.sorted().joinToString("#")

}